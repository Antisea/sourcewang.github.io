---
layout: post
title: Makefile Notes
---

## How to write a makefile

### For program/s compile and link

一般來說，無論是c，c++，首先要把源文件貶義詞中間代碼文件，在windows下也就是.obj文件，unix下時.o文件，即**ObjectFile**，這個動作叫做**編譯**。
然後再把大量的ObjectFile合成執行文件，這個過程叫做**鏈接**。

> 編譯時，編譯器需要的是語法的正確，函數與變量的聲明的正確。

> 鏈接時，通常是你需要告訴編譯器頭文件的所在的位置（頭文件中應該只是聲明，而定義應該放在c/c++文件中），只要所有的語法正確，編譯器就可以編譯出中間目標文件。

> 一般來說，每個源文件都應該對應於一個中間目標文件。

> 鏈接時，主要是鏈接函數和全局變量，所以，我們可以使用這些中間目標文件來鏈接我們的應用程序。鏈接器並不管函數所在的源文件，只管函數的中間目標文件，在大多數時候，由於源文件太多，編譯生成的中間目標文件太多，而在連接時需要明顯的指出中間目標文件名，這對於編譯很不方便，所以**我們要給中間目標文件打個包，在windows下這種包叫庫文件，也就是.lib文件，在unix下時archive file，也就是.a 文件。

> 在鏈接程序時，鏈接器會在所有的object file中尋找函數的實現，如果找不到就會報鏈接錯誤碼linker error，在VC下，這種錯誤一般是**Link 2001**錯誤，也就是說，鏈接器未能找到函數的實現，你需要指定函數的object file。

### Makefile

1. makefile首字母可以是大小也可是小写，不过约定俗成的是大写Makefile。或者是 `make -f Make.Linux`指定文件
2. some rules:
 + 如果这个工程没有编译过，那么所有的c文件都要编译并链接
 + 如果是某几个c文件被修改，值编译修改的c，并链接到目标工程
 + 如果工程的头文件被改变了，值编译引用了这个头文件的c文件，并链接目标程序
3. 只要你的Makefile写的好，所有的动作只需要一个make就可以实现
4. target:目标文件
 - 可以是object file
 - 可以是可执行文件
 - 可以是标签（见"伪目标"）
 - 在同一行，且仅跟在target之后的冒号后面的是prerequisites，也就是要生成那个target所需要的文件或目标,prerequisites中如果有一个以上的文件比target文件要新的话，make就会被执行。
 - target下面跟着的gcc编译命令等一定要以一个TAB开头！！！
 - make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新或者target不要存在的话，那么make就会执行后续定义的命令。
 - make动作只会执行第一个target，想要执行第N个target，输入make加第N个target的名字，例如“make clean”

### Makefile 中使用变量

定义：
	OBJ = main.o a.o b.o c.o

引用：
	$(OBJ)

make 自动推导

> 只要make看到一个.o 文件，它就会自动的吧.c文件加在依赖关系中，如果make找到一个a.o，那么，a.c就会使a.o的依赖文件。并且cc -c a.c 也会被推导出来

### 伪目标

{% highlight c %}
//一般做法
clean:
	rm $(OBJ)

//稳健做法
.PHONY:clean		//只要有这个声明，不过是否有clean文件，要运行clean这个目标，只有make clean
clean:
	-rm $(OBJ)	//减号：也许某些文件出现问题，但不要管，继续做后面的事

{% endhighlight %}

**makefile的注释是“#”**

### 引用其他makefile

1. `include a.mk b.mk c.mk` => `include *.mk`，make命令开始时，会把找寻include所指出的其他makefile，并把其内容安置到当前位。同理`-include a.mk`表示无论include过程出现什么错误，都不要报错，继续执行（sinclude）。

2. make的工作方式
 + 读入所有的Makefile
 + 读入被include的其他Makefile
 + 初始化文件中的变量
 + 推导隐晦规则，并分析其中规则
 + 为所有的目标文件创建依赖关系链
 + 根据依赖关系，决定哪些目标要重新生成
 + 执行生成命令

### 文件搜寻
1. VPATH
2. vpath

### 同时生成多个目标target

{% highlight c %}
all: target1 target2 target3
.PHONY: all

target1:...

target2:...

target3:...
//由于伪目标的特性：总是被执行的。所以其依赖的那三个目标就总是不如all这个目标新，所以。。。

/******************************/
target4 target5: a.o
	cmd

//等价于
target4: a.o
	cmd
target5: a.o
	cmd
{% endhighlight %}

