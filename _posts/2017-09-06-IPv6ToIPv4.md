---
layout: post
title: Ipv4兼容的IPv6地址转换成IPv4地址
---

> 工作中需要将地址转换成序列并与掩码进行与操作，来判断是内网还是外网

### 示例代码

```C
struct in6_addr in6addr;
inet_pton(AF_INET6, wp->ipaddr, (void *)&in6addr);
// 不是IPv4的兼容地址直接返回
if(!IN6_IS_ADDR_V4MAPPED(&in6addr))
  return 0;
// [wzy] 2017-09-06
// wp->ipaddr 格式为IPv6，大致为 ::ffff:192.168.12.90 类似的格式
// inet_addr 直接解析IPv6地址会出错，返回 -1
char cIPv4[32];
sprintf(cIPv4, "%d.%d.%d.%d", in6addr.s6_addr[12], in6addr.s6_addr[13], \
                              in6addr.s6_addr[14], in6addr.s6_addr[15]);
//printf("[wzy]----> cIPv4=%s\r\n", cIPv4);
remote_ip = inet_addr(cIPv4);  
```

> in6_addr的结构体：
```C

struct in6_addr  
{  
    union  
    {  
        uint8_t __u6_addr8[16];   // 128 bit  
        #if defined __USE_MISC || defined __USE_GNU  
        uint16_t __u6_addr16[8];  // 64 bit  
        uint32_t __u6_addr32[4];  // 32 bit  
        #endif  
    } __in6_u;  
    #define s6_addr         __in6_u.__u6_addr8  
    #if defined __USE_MISC || defined __USE_GNU  
    # define s6_addr16      __in6_u.__u6_addr16  
    # define s6_addr32      __in6_u.__u6_addr32  
    #endif  
};  

typedef unsigned char           uint8_t;    
typedef unsigned short int      uint16_t;    
#ifndef __uint32_t_defined    
typedef unsigned int            uint32_t;    
# define __uint32_t_defined    
#endif   

```

> 要想在程序中实现改变ipv6地址的功能，只需要改变in6_addr中u里面的__u6_addr8这个数组里面的内容。
ipv6的格式为X:X:X:X:X:X:X:X,其中每个X表示地址中的16b，以十六进制表示，例如：z的地址是ABCD:EF01：2345：6789：ABCD:EF01：2345：6789
__u6_addr8这个数组里面一共有16个元素，那么平均分配下来每两个元素表示一个X，也就是16b。
__u6_addr8[0]和__u6_addr8[1]代表z地址中第一个16位中的AB和CD。
__u6_addr8[2]和__u6_addr8[3]代表z地址中第二个16位中的EF和01。
__u6_addr8[4]和__u6_addr8[5]代表z地址中第三个16位中的23和45。
以此类推，__u6_addr8数组正好能够将所有的位数都表示。
因为是16进制，所以逢16进1。如果__u6_addr8[0] = 16，__u6_addr8[1] = 10，那么前16位就是：100a。
数组元素里面最大是255，因为两位16进制的数能够表示最大的数就是ff。

```C

in6_addr p;  
p.__in6_u.__u6_addr8[0] = 255;  
p.__in6_u.__u6_addr8[1] = 255;  
p.__in6_u.__u6_addr8[2] = 255;  
p.__in6_u.__u6_addr8[3] = 0;  
p.__in6_u.__u6_addr8[4] = 0;  
p.__in6_u.__u6_addr8[5] = 255;  
p.__in6_u.__u6_addr8[6] = 16;  
p.__in6_u.__u6_addr8[7] = 1;  
p.__in6_u.__u6_addr8[8] = 255;  
p.__in6_u.__u6_addr8[9] = 17;  
p.__in6_u.__u6_addr8[10] = 15;  
p.__in6_u.__u6_addr8[11] = 255;  
p.__in6_u.__u6_addr8[12] = 10;  
p.__in6_u.__u6_addr8[13] = 10;  
p.__in6_u.__u6_addr8[14] = 1;  
p.__in6_u.__u6_addr8[15] = 10;  

```
> 上面程序打印出来的结果就是：ffff:ff00:ff:1001:ff11:fff:a0a:10a

```C
这个代码没验证过
char* hexToCharIP(struct in_addr addrIP)
{ 
  char* ip;  
  unsigned int intIP;  
  memcpy(&intIP, &addrIP,sizeof(unsigned int));  
  int a = (intIP >> 24) & 0xFF;  
  int b = (intIP >> 16) & 0xFF;  
  int c = (intIP >> 8) & 0xFF;  
  int d = intIP & 0xFF;  
  if((ip = (char*)malloc(16*sizeof(char))) == NULL)  
  {  
    return NULL;  
  }  
  sprintf(ip, "%d.%d.%d.%d", d,c,b,a);  
  return ip;  
}  

```


### 相关资料链接

http://blog.csdn.net/crescent__moon/article/details/51985140

http://bbs.csdn.net/topics/390257822

man inet_addr

man inet_pton

> man手册里面有示例代码，用来参考很有用

