---
layout: post
title: Linux 相关知识
---

平时工作学习中遇到的Linux的相关知识累积


## Sendfile

### Sendfile机制：

> 用户将请求发给内核，内核根据用户的请求调用相应的用户进程，进程在处理时需要资源，此时再把请求发给内核（进程没有直接IO的能力），
由内核加载数据。内核查找到数据之后，会把数据复制给用户进程，由用户进程对数据进行封装，之后交给内核，内核在进行tcp/ip 首部的
封装，最后在发送给客户端。这个功能用户进程只是发生了一个封装报文的过程，却要绕一大圈。

> 因此ngix 引入了sendfile 机制，使得内核在接收到数据之后，不再依靠用户进程给予封装，而是自己查找自己封装，减少了一个很长一段
时间的浪费，这是一个提升性能的核心点。

> 简单来说，就是资源的处理，直接通过内核层进行数据传递，避免了数据传递到应用层，应用层再传递到内核层的开销。

> 目前高并发的处理一般都是采用sendfile 模式，通过直接操作内核层数据减少应用于内核层数据传递

## buffers与cached的异同

* 在Linux操作系统中，当应用程序需要读取文件中的数据时，操作系统先分配一些内存，将数据从磁盘读入到这些内存中，然后再将数据分发给应用程序；当需要往文件中写数据时，操作系统先分配内存接收用户数据，然后再将数据从内存写到磁盘上。然而，如果有大量数据需要从磁盘读取到内存或者由内存写入磁盘时，系统的读写性能就变得非常低下，因为无论是从磁盘读数据，还是写数据到磁盘，都是一个很消耗时间和资源的过程，在这种情况下，Linux引入了buffers和cached机制。

* buffers与cached都是**内存操作**，用来保存系统曾经打开过的文件以及文件属性信息，这样当操作系统需要读取某些文件时，会首先在buffers与cached内存区查找，如果找到，直接读出传送给应用程序，如果没有找到需要数据，才从磁盘读取，这就是操作系统的缓存机制，通过缓存，大大提高了操作系统的性能。但buffers与cached缓冲的内容却是不同的。

* **buffers是用来缓冲块设备**的，它只记录文件系统的元数据（metadata）以及 tracking in-flight pages，而**cached是用来给文件做缓冲**。更通俗一点说：buffers主要用来存放目录里面有什么内容，文件的属性以及权限等等。而cached直接用来记忆我们打开过的文件和程序。

## MDK3D

`setenv sourcewang 'tftp 41000000 sourcewang/uImage;tftp 42000000 sourcewang/uInitrd;tftp 43000000 sourcewang/board.dtb;bootm 41000000 42000000 43000000'`

`run sourcewang`

`source build/envsetup.sh`

`make linux` -> gen uImage and l602.dtb

`make buildroot` -> uInitrd(file system)

`ifconfig eth0 10.193.208.220 netmask 255.255.255.0`

`route add default gw 10.193.208.1`

`mount -f nfs 10.193.208.131:/tftpboot/sourcewang /mnt -o nolock`


Lighttpd 在arm上的移植，支持pcre正则，zlib，openssl

## Lighttpd

Lighttpd version: 1.4.39   
GCC tool chain: arm-none-linux-gnueabi

在此之前，你必须首先交叉编译好pcre, zlib, openssl

### Configuration

* configure

{% highlight shell %}

#!/bin/sh
CFLAGS="-I/home/sourcewang/opt/pcre-8.36-arm/include -I/home/sourcewang/opt/zlib-1.2.8-arm/include" LDFLAGS="-L/home/sourcewang/opt/pcre-8.36-arm/lib -L/home/sourcewang/opt/zlib-1.2.8-arm/lib" ./configure --prefix=/home/sourcewang/opt/lighttpd-1.4.39-arm --host=arm-none-linux-gnueabi --without-bzip2 --with-openssl --with-openssl-includes=/home/sourcewang/opt/openssl-1.0.2f-arm/include --with-openssl-libs=/home/sourcewang/opt/openssl-1.0.2f-arm/lib

{% endhighlight %}

* make

* make install

### lighttpd.conf

1. check all kinds of dirs which contains of logdir, serverrootdir, confdir and so on
2. check username
 * username 默认为www-data 或nobody，将其修改成你当前登录的用户名或者是超级用户（必须是存在的用户）或者设为空
 * ipv6 disable 或者注释掉 / 若出现sendfile 错误，找到配置文件里面那一行，注释掉

### Enable cgi and fastcgi and https

由于lighttpd.conf include 了module.conf，请自行决定以下的修改是在哪个地方

##### CGI enable

{% highlight java %}

server.modules = (
	"mod_access",
	"mod_cgi",  //enable cgi module
	...
)

cgi.assign = (
	".cgi" => ""   //指定以.cgi 为后缀的文件用什么方式执行，空表示自动寻找能执行.cgi 文件的程式来执行
)

{% endhighlight %}

##### FASTCGI enable to run with php

修改fastcgi.conf

{% highlight java %}

server.modules += ("mod_fastcgi")

fastcgi.server = ( ".php" => 
	((
		"socket" => "/usr/bin/php.socket",     //这个php.socket是凭空生成的，只需要给他指定一个可存放的路径即可
		"bin-path" => "/usr/bin/php-cgi",      //一定要指到安装好的php路径下的php-cgi可执行档
		"bin-environment" => (
			"php-FCGI_CHILDREN" => "16",
			"php-FCG_MAX_REQUESTS" => "10000"
		),
		"min-procs" => 1,
		"max-procs" => 1,
		"idle-timeout" => 20
	))
)

{% endhighlight %}

##### OpenSSL support

* generate server.pem     自认证证书

`openssl req -new -x509 -keyout server.pem -out server.pem -days 3650 -nodes`

> [详细信息请查询lighttpd 官网](http://www.lighttpd.net "lighttpd 官网")

* modify lighttpd.conf

{% highlight java %}

$SERVER["socket"] == ":443" {
	ssl.engine = "enable"
	ssl.pemfile = "/your/server.pem/path"
	}

{% endhighlight %}

### start lighttpd server

`./sbin/lighttpd -f conf/lighttpd.conf`

### test cgi and php

##### cgi

1. gcc helloworld.c -o helloworld.cgi
2. cp helloworld.cgi to your server_root_dir_cgi-bin
3. access http(s)://your-server-ip/cgi-bin/helloworld.cgi

##### php

1. use simple function `phpinfo();` to check if php works well
2. access http(s)://your-server-ip/cgi-bin/phpinfo.php


简单的u-boot启动说明

## U-BOOT

* uboot正常启动后，会调用main_loop(void)函数，进入main_loop()之后，如果在规定的时间`CONFIG_BOOTDELAY`内，没有检查到任何按键事件的发生，就会去加载OS，并启动系统，比如把linux内核压缩镜像从nand flash中读到sdram ，然后执行它。

* 如果在`CONFIG_BOOTDELAY`时间内，用户按下键盘上的任意一个按键，uboot就会进入与用户交互的状态。如果用户在配置文件中定义了`CONFIG_SYS_HUSH_PARSER`，就会通过`parse_file_outer()`，去接收并解析用户命令，否则进入一个for（;;）循环中，通过`readline(CONFIG_SYS_PROMPT)`接收用户命令，然后调用`run_command(cmd,flag)`去解析并执行命令。

Repo 简单用法

## 简单用法

### Repo 方式

> repo 是google 出品的调用git 进行下载的脚本，他可以下载并管理多个git库，而这个整体，我们称为repo库
    
    repo init -u $URL -b $branch
    repo sync
    //repo sync -j 6 后面-j 的意思是启用几个并发进程下载代码

### Git 方式

> 针对单个git库进行下载

    git clone $URL -b $branch

### 简单报错排查

1. key 是否配好
* ssh -p PORT $username@server

2. 在init 阶段出错
* repo文件有问题，检查repo文件：
** 检查环境变量的配置
* 已经init 过，或者父目录已经init 过，导致无法init

3. 刚开始sync就出错
* repo有问题
* 没有权限，导致无法下载，查看该用户是否有权限
* 有权限，检查.netrc 和.gitconfig 配置，查看是否正确配置了账户和密码

4. sync一段后出错
* 本身库的权限是有的，但是group的权限没有
* 在下载过程中，父目录做过init操作

5. 其他
* 网络出现问题
* git版本与gitlab不兼容
* 系统版本有时也会影响


## How to write a makefile

### For program/s compile and link

一般來說，無論是c，c++，首先要把源文件貶義詞中間代碼文件，在windows下也就是.obj文件，unix下時.o文件，即**ObjectFile**，這個動作叫做**編譯**。
然後再把大量的ObjectFile合成執行文件，這個過程叫做**鏈接**。

> 編譯時，編譯器需要的是語法的正確，函數與變量的聲明的正確。

> 鏈接時，通常是你需要告訴編譯器頭文件的所在的位置（頭文件中應該只是聲明，而定義應該放在c/c++文件中），只要所有的語法正確，編譯器就可以編譯出中間目標文件。

> 一般來說，每個源文件都應該對應於一個中間目標文件。

> 鏈接時，主要是鏈接函數和全局變量，所以，我們可以使用這些中間目標文件來鏈接我們的應用程序。鏈接器並不管函數所在的源文件，只管函數的中間目標文件，在大多數時候，由於源文件太多，編譯生成的中間目標文件太多，而在連接時需要明顯的指出中間目標文件名，這對於編譯很不方便，所以**我們要給中間目標文件打個包，在windows下這種包叫庫文件，也就是.lib文件，在unix下時archive file，也就是.a 文件。

> 在鏈接程序時，鏈接器會在所有的object file中尋找函數的實現，如果找不到就會報鏈接錯誤碼linker error，在VC下，這種錯誤一般是**Link 2001**錯誤，也就是說，鏈接器未能找到函數的實現，你需要指定函數的object file。

### Makefile

1. makefile首字母可以是大小也可是小写，不过约定俗成的是大写Makefile。或者是 `make -f Make.Linux`指定文件
2. some rules:
 + 如果这个工程没有编译过，那么所有的c文件都要编译并链接
 + 如果是某几个c文件被修改，值编译修改的c，并链接到目标工程
 + 如果工程的头文件被改变了，值编译引用了这个头文件的c文件，并链接目标程序
3. 只要你的Makefile写的好，所有的动作只需要一个make就可以实现
4. target:目标文件
 - 可以是object file
 - 可以是可执行文件
 - 可以是标签（见"伪目标"）
 - 在同一行，且仅跟在target之后的冒号后面的是prerequisites，也就是要生成那个target所需要的文件或目标,prerequisites中如果有一个以上的文件比target文件要新的话，make就会被执行。
 - target下面跟着的gcc编译命令等一定要以一个TAB开头！！！
 - make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新或者target不要存在的话，那么make就会执行后续定义的命令。
 - make动作只会执行第一个target，想要执行第N个target，输入make加第N个target的名字，例如“make clean”

### Makefile 中使用变量

定义：
	OBJ = main.o a.o b.o c.o

引用：
	$(OBJ)

make 自动推导

> 只要make看到一个.o 文件，它就会自动的吧.c文件加在依赖关系中，如果make找到一个a.o，那么，a.c就会使a.o的依赖文件。并且cc -c a.c 也会被推导出来

### 伪目标

{% highlight c %}
//一般做法
clean:
	rm $(OBJ)

//稳健做法
.PHONY:clean		//只要有这个声明，不过是否有clean文件，要运行clean这个目标，只有make clean
clean:
	-rm $(OBJ)	//减号：也许某些文件出现问题，但不要管，继续做后面的事

{% endhighlight %}

**makefile的注释是“#”**

### 引用其他makefile

1. `include a.mk b.mk c.mk` => `include *.mk`，make命令开始时，会把找寻include所指出的其他makefile，并把其内容安置到当前位。同理`-include a.mk`表示无论include过程出现什么错误，都不要报错，继续执行（sinclude）。

2. make的工作方式
 + 读入所有的Makefile
 + 读入被include的其他Makefile
 + 初始化文件中的变量
 + 推导隐晦规则，并分析其中规则
 + 为所有的目标文件创建依赖关系链
 + 根据依赖关系，决定哪些目标要重新生成
 + 执行生成命令

### 文件搜寻
1. VPATH
2. vpath

### 同时生成多个目标target

{% highlight c %}
all: target1 target2 target3
.PHONY: all

target1:...

target2:...

target3:...
//由于伪目标的特性：总是被执行的。所以其依赖的那三个目标就总是不如all这个目标新，所以。。。

/******************************/
target4 target5: a.o
	cmd

//等价于
target4: a.o
	cmd
target5: a.o
	cmd
{% endhighlight %}


# Cross Compiler For ARM

# Lighttpd 

{% highlight SHELL %}

#!/bin/sh
CFLAGS="-I/home/sourcewang/opt/pcre-8.36-arm/include -I/home/sourcewang/opt/zlib-1.2.8-arm/include" LDFLAGS="-L/home/sourcewang/opt/pcre-8.36-arm/lib -L/home/sourcewang/opt/zlib-1.2.8-arm/lib" ./configure --prefix=/home/sourcewang/opt/lighttpd-1.4.39-arm --host=arm-none-linux-gnueabi --without-bzip2 --with-openssl --with-openssl-includes=/home/sourcewang/opt/openssl-1.0.2f-arm/include --with-openssl-libs=/home/sourcewang/opt/openssl-1.0.2f-arm/lib

{% endhighlight %}

# OpenSSL

{% highlight SHELL %}

#!/bin/sh
CC=arm-none-linux-gnueabi-gcc ./Configure linux-elf --openssldir=/home/sourcewang/opt/openssl-1.0.2f-arm/openssl no-asm shared --prefix=/home/sourcewang/opt/openssl-1.0.2f-arm

{% endhighlight %}

# PHP

{% highlight SHELL %}

#!/bin/sh
./configure --prefix=/tftpboot/sourcewang/opt/php-5.6.18 --with-config-file-path=/tftpboot/sourcewang/opt/php-5.6.18/ --enable-soap --enable-sysvmsg --with-openssl-dir=/tftpboot/sourcewang/opt/openssl-1.0.2f/ --enable-ftp --enable-sockets --with-pcre-dir

{% endhighlight %}

# cURL

{% highlight SHELL %}

#!/bin/sh
LDFLAGS=-R/home/sourcewang/opt/openssl-1.0.2f-arm/lib ./configure --prefix=/home/sourcewang/opt/curl-7.20.0-arm --host=arm-none-linux-gnueabi --with-ssl=/home/sourcewang/opt/openssl-1.0.2f-arm

{% endhighlight %}

# WolfSSL

# PCRE

# ZLIB

# Wpa_supplicant


# Samba

{% highlight SHELL %}
make && make install
{% endhighlight %}


